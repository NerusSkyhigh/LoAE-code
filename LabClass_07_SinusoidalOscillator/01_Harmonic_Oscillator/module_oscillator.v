/*
 * PROBLEM 01:
 *	Implementation of a harmonic oscillator:
 * 		- development of the oscillator;
 *		- characterization of operation of the oscillator as a function
 *			of the input parameter k.
 */
/*
 * Boundaries condition are generated by noticing
 * that sin(x) is symmetric around the maximum
 */

/*
 * By inverting the relation c = (1-omega^2 T^2/4)/(1+omega^2 T^2/4)
 * we get omega = 2/T sqrt{1/[1+2^(k+2)]}
 */
module Module_Oscillator(input				clk_in,
												 input [3:0]	k, // Frequency of the wf
												 input				loadBoundaryCondition,
												 input [16:0] boundaryCondition,

												 output	[11:0] wave);

reg signed [16:0]	y;
reg signed [16:0]	yOld;

buf(wave, y >> 4);

always @(posedge clk_in) begin
	if (loadBoundaryCondition) begin
		y <= boundaryCondition; // Maximum of the WF
		yOld <= (boundaryCondition >> (k+1)) - boundaryCondition;
	end else begin
		yOld <= -y;

		y <= (y << 1) - (y >> k) + yOld + 1;
	end
end

/*
 * I can't make it work despite looking good.
 * There probably still is a problem with a reminder
 * that I can't point out.
 */
/*
reg [16:0]	y;
reg [16:0]	yOld;

buf(wave, y >> 4);

always @(posedge clk_in) begin
	if (loadBoundaryCondition) begin
		y <= boundaryCondition;
		// To save cycles yOld = -y[n-1] is stored.
		yOld <= (boundaryCondition >> (k+1)) + ~boundaryCondition;
	end else begin
		yOld <= ~y;
		y <= (y << 1) + yOld + (
							// As we are dealing with both positive and negative numbers we need to be
							// sure to bitshift correctly. In this case the bitshift is performed when
							// the number is positive. This is to avoid adding trailing zeros to a two's
							// complement number.
							(y[16]) ? ((~y + 1) >> k) : (~(y >> k) + 1)	);
	end
end
*/

endmodule




/*
 * PROBLEM 02:
 *	Implementation of a second harmonic oscillator working
 *	in quadrature with the first one.
 * 	The final result should look like the result visible
 *	in point 4. (and point 3.) of preliminary operations.
 */
module Module_Quadrature_Oscillator( input				clk_in,
																		 input [11:0]	sin,
																		 input [3:0]	k,
																		 input				loadBoundaryCondition,
																		 input [16:0] boundaryCondition,

																		 output	[11:0] wave);

reg signed [16:0]	y;
reg signed [16:0]	yOld;
buf(wave, y >> 4);


reg sign_sin_old;
reg wait_for_sync;

always @(posedge clk_in) begin
	if (loadBoundaryCondition) begin
		wait_for_sync <= 1;
		sign_sin_old <= sin[11];
	end

	if(wait_for_sync) begin
		if( (sign_sin_old == 0) && (sin[11] == 1) ) begin
			wait_for_sync <= 0;
			y <= boundaryCondition;
			yOld <= (boundaryCondition >> (k+1)) - boundaryCondition;
		end else begin
			sign_sin_old <= sin[11];
		end
	end else begin
		yOld <= -y;
		y <= (y << 1) - (y >> k) + yOld + 1;
	end

end

endmodule
